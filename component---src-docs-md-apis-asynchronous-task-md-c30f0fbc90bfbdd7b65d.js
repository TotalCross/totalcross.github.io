(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{xxpz:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return s})),n.d(t,"default",(function(){return d}));n("91GP"),n("rGqo"),n("yt8O"),n("Btvt"),n("RW0V"),n("FlsD"),n("q1tI");var a=n("7ljp"),r=n("hhGP");n("qKvR");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var s={};void 0!==s&&s&&s===Object(s)&&Object.isExtensible(s)&&!s.hasOwnProperty("__filemeta")&&Object.defineProperty(s,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docs/md/apis/asynchronous-task.md"}});var i={_frontmatter:s},c=r.a;function d(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(c,o({},i,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"asynchronous-task"},"Asynchronous Task"),Object(a.b)("p",null,"Executing background tasks in order to not lock the Main Thread."),Object(a.b)("h2",{id:"using-asynctask-class-to-execute-background-tasks"},"Using AsyncTask class to execute background tasks"),Object(a.b)("p",null,"In order to execute task that can take a few seconds to be completely executed, one must run it apart from the main thread, i.e, the thread responsible for painting components. Executing this kind of task in the main thread may cause a non-good user experience, once the application user may be unable to use and see any progress while the task is being executed."),Object(a.b)("p",null,"To avoid such an obstacle, TotalCross provides AsyncTask class, which is a helper to execute task in an asynchronous way. By using AsyncTask, the user can easily execute asynchronous task without complex manipulation of threads and, consequently, not locking the main thread. See the example bellow to learn how to use it."),Object(a.b)("p",null,"Copy and paste this code inside a ",Object(a.b)("a",o({parentName:"p"},{href:"control/container.md"}),"Container")," instance."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-java"}),'Button dldButton = new Button("download zip");\nadd(dldButton, CENTER, CENTER);\n\nfinal ProgressBar progressBar = new ProgressBar();\nadd(progressBar, CENTER, AFTER + UnitsConverter.toPixels(DP + 16),\n        PARENTSIZE + 80, PREFERRED);\n\ndldButton.addPressListener((c) -> {\n    new AsyncTask()<Void, Void, Void> {\n        int progress = 0;\n        UpdateListener updateListener = null;\n\n        @Override\n        protected Object doInBackground(Object... objects) {\n            HttpStream.Options o = new HttpStream.Options();\n            o.httpType = HttpStream.GET;\n            final String url = "<INSERT AN URL TO DOWNLOAD A ZIP FILE>";\n\n            if(url.startsWith("https:"))\n                o.socketFactory = new SSLSocketFactory();\n\n            try {\n                HttpStream p = new HttpStream(new URI(url));\n                File f = new File("file.zip", File.CREATE_EMPTY);\n                int totalSize = p.contentLength;\n                byte [] buff = new  byte[4096];\n                BufferedStream bs = new BufferedStream(f, BufferedStream.WRITE, 4096);\n                int counter = 0;\n                while(true) {\n                    int size = p.readBytes(buff, 0, buff.length);\n                    counter += size;\n                    progress = (int)((counter/(double)totalSize)*100);\n                    if(size <= 0) break;\n                    bs.writeBytes(buff, 0, size);\n                }\n                progress = 100;\n                bs.close();\n                p.close();\n                f.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        @Override\n        protected void onPreExecute() {\n            dldButton.setEnabled(false);\n            MainWindow.getMainWindow().addUpdateListener(updateListener = (elapsed) -> {\n                progressBar.setValue(progress);\n            });\n        }\n\n        @Override\n        protected void onPostExecute(Object result) {\n            dldButton.setEnabled(true);\n            MainWindow.getMainWindow().removeUpdateListener(updateListener);\n        }\n    }.execute();\n});\n')),Object(a.b)("p",null,"Once method execute is called, before executing the asynchronous task, ",Object(a.b)("em",{parentName:"p"},"onPreExecute")," method is also called adding an ",Object(a.b)("em",{parentName:"p"},"UpdateListener")," to update the component ",Object(a.b)("a",o({parentName:"p"},{href:"../components/progress-bar.md"}),Object(a.b)("inlineCode",{parentName:"a"},"ProgressBar"))," in the adequate time interval trough the variable ",Object(a.b)("em",{parentName:"p"},"progress"),". The button dldButton is disabled to avoid user execute the same task many times unnecessarily."),Object(a.b)("p",null,"When the file is completely downloaded, the function ",Object(a.b)("em",{parentName:"p"},"onPostExecute")," is called removing the ",Object(a.b)("em",{parentName:"p"},"UpdateListener")," and ",Object(a.b)("strong",{parentName:"p"},"reenabling "),"the button ",Object(a.b)("em",{parentName:"p"},"dldButton.")))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docs/md/apis/asynchronous-task.md"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docs-md-apis-asynchronous-task-md-c30f0fbc90bfbdd7b65d.js.map